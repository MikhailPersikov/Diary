<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://kit.fontawesome.com/ba5f0bb903.js" crossorigin="anonymous"></script>
    <link rel="stylesheet" href="../CSS/style.css">
    <title>Comparison Operators</title>

</head>

<body>
    <header class="head">
        <div class="head__wrapper">
            <div class="social__wrapper">
                <ul class="social__ul">
                    <li class="social__icons"><a href="https://twitter.com" class=" link__btn fab fa-twitter"></a></li>
                    <li class="social__icons"><a href="https://www.linkedin.com/" class="link__btn fab fa-linkedin"></a>
                    </li>
                    <li class="social__icons"><a href="https://t.me/texasjkee" class="link__btn fas fa-paper-plane"></a>
                    </li>
                </ul>
            </div>
        </div>
    </header>
    <a class="back__btn" href="../index.html">Back</a>
    <h2>Операторы сравнения</h2>
    <p>Больше/меньше: a > b, a < b.</p>
            <p>Больше/меньше или равно: a >= b, a <= b.</p>
                    <p>Равно: a == b. Обратите внимание, для сравнения используется двойной знак равенства ==. Один знак
                        равенства a = b означал бы присваивание.</p>
                    <p>Не равно. В математике обозначается символом ≠, но в JavaScript записывается как a != b.
                    </p>
                    <h2>Результат сравнения имеет логический тип</h2>
                    <p>Все операторы сравнения возвращают значение логического типа:</p>
                    <p>true – означает «да», «верно», «истина».</p>
                    <p>false – означает «нет», «неверно», «ложь».</p>
                    <p>Например:</p>
                    <p>alert( 2 > 1 ); // true (верно) <br>
                        alert( 2 == 1 ); // false (неверно) <br>
                        alert( 2 != 1 ); // true (верно)</p>
                    <p>Результат сравнения можно присвоить переменной, как и любое значение:</p>
                    <p>let result = 5 > 4; // результат сравнения присваивается переменной result<br>
                        alert( result ); // true</p>
                    <h2>Сравнение строк</h2>
                    <p>Чтобы определить, что одна строка больше другой, JavaScript использует
                        <strong>«алфавитный»</strong> или <strong>«лексикографический»</strong> порядок.</p>
                    <p>alert( 'Я' > 'А' ); // true</p>
                    <p>alert( 'Коты' > 'Кода' ); // true</p>
                    <p>alert( 'Сонный' > 'Сон' ); // true</p>
                    <p><strong>Алгоритм сравнения:</strong></p>
                    <p>1. Сначала сравниваются первые символы строк.</p>
                    <p>2. Если первый символ первой строки больше (меньше), чем первый символ второй, то первая строка
                        больше (меньше) второй. Сравнение завершено.</p>
                    <p>3. Если первые символы равны, то таким же образом сравниваются уже вторые символы строк.</p>
                    <p>4. Сравнение продолжается, пока не закончится одна из строк.</p>
                    <p>5. Если обе строки заканчиваются одновременно, то они равны. Иначе, большей считается более
                        длинная строка.</p>
                    <p>В примерах выше сравнение 'Я' > 'А' завершится на первом шаге, тогда как строки 'Коты' и 'Кода'
                        будут сравниваться посимвольно:</p>
                    <p>1. К равна К.</p>
                    <p>2. о равна о.</p>
                    <p>3. т больше, чем д. На этом сравнение заканчивается. Первая строка больше.</p>
                    <h2>Сравнение разных типов</h2>
                    <p>При сравнении значений разных типов JavaScript приводит каждое из них к числу.</p>
                    <p>alert( '2' > 1 ); // true, строка '2' становится числом 2</p>
                    <p>alert( '01' == 1 ); // true, строка '01' становится числом 1</p>
                    <p>Логическое значение true становится 1, а false – 0.</p>
                    <p>alert( true == 1 ); // true <br>
                        alert( false == 0 ); // true</p>
                    <h2>Строгое сравнение</h2>
                    <p>alert( 0 == false ); // true</p>
                    <p>Та же проблема с пустой строкой:</p>
                    <p>alert( '' == false ); // true</p>
                    <p>Это происходит из-за того, что операнды разных типов преобразуются оператором == к числу. В
                        итоге, и пустая строка, и false становятся нулём.  <br>

                        Как же тогда отличать 0 от false? <br>

                        Оператор строгого равенства  <strong>===</strong>  проверяет равенство без приведения типов.  <br>

                        Другими словами, если a и b имеют разные типы, то проверка a === b немедленно возвращает false  <br>
                        без попытки их преобразования.  <br>

                    </p>
                    <h2>Сравнение с null и undefined</h2>
                    <p>Поведение null и undefined при сравнении с другими значениями — особое:</p>
                    <p>При строгом равенстве ===</p>
                    <p>Эти значения различны, так как различны их типы.</p>
                    <p>alert( null === undefined ); // false</p>
                    <p>При нестрогом равенстве ==</p>
                    <p>Эти значения равны друг другу и не равны никаким другим значениям. Это специальное правило языка.</p>
                    <p>alert( null == undefined ); // true</p>
                    <p>При использовании математических операторов и других операторов сравнения < > <= >=</p>
                    <p>Значения null/undefined преобразуются к числам: null становится 0, а undefined – NaN.</p>
                    <p>Посмотрим, какие забавные вещи случаются, когда мы применяем эти правила. И, что более важно, как избежать ошибок при их использовании.</p>
                    <p>Странный результат сравнения null и 0</p>
                    <p>Сравним null с нулём:</p>
                    <p>alert( null > 0 );  // (1) false <br>
                        alert( null == 0 ); // (2) false  <br>
                        alert( null >= 0 ); // (3) true</p>
                    <p>С точки зрения математики это странно. Результат последнего сравнения говорит о том, что "null больше или равно нулю", тогда результат одного из сравнений выше должен быть true, но они оба ложны. <br>

                        Причина в том, что нестрогое равенство и сравнения > < >= <= работают по-разному. Сравнения преобразуют null в число, рассматривая его как 0. Поэтому выражение (3) null >= 0 истинно, а null > 0 ложно. <br>
                        
                        С другой стороны, для нестрогого равенства == значений undefined и null действует особое правило: эти значения ни к чему не приводятся, они равны друг другу и не равны ничему другому. Поэтому (2) null == 0 ложно.</p>
                    <h3>Несравненное значение undefined</h3>
                    <p>Значение undefined несравнимо с другими значениями:</p>
                    <p>alert( undefined > 0 ); // false (1) <br>
                        alert( undefined < 0 ); // false (2) <br>
                        alert( undefined == 0 ); // false (3)</p>
                    
                    
</body>

</html>