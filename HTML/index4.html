<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://kit.fontawesome.com/ba5f0bb903.js" crossorigin="anonymous"></script>
    <link rel="stylesheet" href="../CSS/style.css">
    <title>Logical operators</title>
</head>

<body>
    <header class="head">
        <div class="head__wrapper">
            <div class="social__wrapper">
                <ul class="social__ul">
                    <li class="social__icons"><a href="https://twitter.com" class=" link__btn fab fa-twitter"></a></li>
                    <li class="social__icons"><a href="https://www.linkedin.com/" class="link__btn fab fa-linkedin"></a>
                    </li>
                    <li class="social__icons"><a href="https://t.me/texasjkee" class="link__btn fas fa-paper-plane"></a>
                    </li>
                </ul>
            </div>
        </div>
    </header>
    <a class="back__btn" href="../index.html">Back</a>
    <h2>Логические операторы</h2>
    <p>В JavaScript есть три логических оператора: || (ИЛИ), && (И) и ! (НЕ).</p>
    <h2>|| (ИЛИ)</h2>
    <p>Существует всего четыре возможные логические комбинации:</p>
    <p>
        alert( true || true ); // true <br>
        alert( false || true ); // true <br>
        alert( true || false ); // true <br>
        alert( false || false ); // false 
    </p>
    <h2>ИЛИ «||» находит первое истинное значение</h2>
    <p>Описанная выше логика соответствует традиционной. Теперь давайте поработаем с «дополнительными» возможностями JavaScript.

        Расширенный алгоритм работает следующим образом.
        
        При выполнении ИЛИ || с несколькими значениями: <br>
        
        result = value1 || value2 || value3;</p>
    <p>Оператор || выполняет следующие действия:</p>
    <p>Вычисляет операнды слева направо.</p>
    <p>Каждый операнд конвертирует в логическое значение. Если результат true, останавливается и возвращает исходное значение этого операнда.</p>
    <p>Если все операнды являются ложными (false), возвращает последний из них.</p>
    <p>Значение возвращается в исходном виде, без преобразования.</p>
    <p>Другими словами, цепочка ИЛИ "||" возвращает первое истинное значение или последнее, если такое значение не найдено.</p>
    <p>alert( 1 || 0 ); // 1 <br>
        alert( true || 'no matter what' ); // true <br>
        
        alert( null || 1 ); // 1 (первое истинное значение) <br>
        alert( null || 0 || 1 ); // 1 (первое истинное значение) <br>
        alert( undefined || null || 0 ); // 0 (поскольку все ложно, возвращается последнее значение)</p>
    <p>Это делает возможным более интересное применение оператора по сравнению с «чистым, традиционным, только булевым ИЛИ».</p>
    <h3>Сокращённое вычисление.</h3>
    <p>Операндами могут быть как отдельные значения, так и произвольные выражения. ИЛИ вычисляет их слева направо. Вычисление останавливается при достижении первого истинного значения. Этот процесс называется «сокращённым вычислением», поскольку второй операнд вычисляется только в том случае, если первого недостаточно для вычисления всего выражения.</p>
    <p>Это хорошо заметно, когда выражение, указанное в качестве второго аргумента, имеет побочный эффект, например, изменение переменной.</p>
    <p>let x; <br>

        true || (x = 1); <br>
        
        alert(x); // undefined, потому что (x = 1) не вычисляется</p>
    <p>Если бы первый аргумент имел значение false, то || приступил бы к вычислению второго и выполнил операцию присваивания:</p>
    <p>let x; <br>

        false || (x = 1); <br>
        
        alert(x); // 1</p>
    <p>Присваивание – лишь один пример. Конечно, могут быть и другие побочные эффекты, которые не проявятся, если вычисление до них не дойдёт.</p>
    <p>Как мы видим, этот вариант использования || является "аналогом if". Первый операнд преобразуется в логический. Если он оказывается ложным, начинается вычисление второго.</p>
    <p>В большинстве случаев лучше использовать «обычный» if, чтобы облегчить понимание кода, но иногда это может быть удобно.</p>
    <h3>&& (И)</h3>
    <p>Оператор И пишется как два амперсанда &&:</p>
    <p>При нескольких подряд операторах И:</p>
    <p>result = value1 && value2 && value3;</p>
    <p>Оператор && выполняет следующие действия:</p>
    <p>Вычисляет операнды слева направо.</p>
    <p>Каждый операнд преобразует в логическое значение. Если результат false, останавливается и возвращает исходное значение этого операнда.</p>
    <p>Если все операнды были истинными, возвращается последний.</p>
    <p>Другими словами, И возвращает первое ложное значение. Или последнее, если ничего не найдено.</p>
    <p>Вышеуказанные правила схожи с поведением ИЛИ. Разница в том, что И возвращает первое ложное значение, а ИЛИ –  первое истинное.</p>
    <p>// Если первый операнд истинный, 
        // И возвращает второй:  <br>
        alert( 1 && 0 ); // 0  <br>
        alert( 1 && 5 ); // 5  <br>
        <br>
        
        // Если первый операнд ложный,  <br>
        // И возвращает его. Второй операнд игнорируется  <br>
        alert( null && 5 ); // null  <br>
        alert( 0 && "no matter what" ); // 0</p> 
    <p>Можно передать несколько значений подряд. В таком случае возвратится первое «ложное» значение, на котором остановились вычисления.</p>
    <p>alert( 1 && 2 && null && 3 ); // null</p>
    <p>Когда все значения верны, возвращается последнее</p>
    <p>alert( 1 && 2 && 3 ); // 3</p>
    <p>Как и оператор ИЛИ, И && иногда может заменять if.</p>
    <p>let x = 1; <br>

        (x > 0) && alert( 'Greater than zero!' );</p>
    <p>Действие в правой части && выполнится только в том случае, если до него дойдут вычисления. То есть, alert сработает, если в левой части (x > 0) будет true. <br>

        Получился аналог:</p>
    <p>Однако, как правило, вариант с if лучше читается и воспринимается.</p>
    <p>Он более очевиден, поэтому лучше использовать его.</p>
    <h2>! (НЕ)</h2>
    <p>Оператор НЕ представлен восклицательным знаком  <strong>!</strong>.</p>
    <p>Синтаксис довольно прост:</p>
    <p>result = !value;</p>
    <p>Оператор принимает один аргумент и выполняет следующие действия:</p>
    <p>Сначала приводит аргумент к логическому типу true/false.</p>
    <p>Затем возвращает противоположное значение.</p>
    <p>Например:</p>
    <p>alert( !true ); // false</p>
    <p>alert( !0 ); // true</p>
    <p>В частности, двойное НЕ используют для преобразования значений к логическому типу:</p>
    <p>alert( !!"non-empty string" ); // true</p>
    <p>alert( !!null ); // false</p>
    <p>То есть первое НЕ преобразует значение в логическое значение и возвращает обратное, а второе НЕ снова инвертирует его. В конце мы имеем простое преобразование значения в логическое.</p>
    <p>Есть немного более подробный способ сделать то же самое – встроенная функция Boolean:</p>
    <p>alert( Boolean("non-empty string") ); // true</p>
    <p>alert( Boolean(null) ); // false</p>
    <p>Приоритет НЕ ! является наивысшим из всех логических операторов, поэтому он всегда выполняется первым, перед && или ||.</p>
</body>

</html>